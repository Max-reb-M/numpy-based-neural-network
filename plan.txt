2 Files:
    - initialization file with all functions
    - main file with implementation

main file:
    1. Prepare Dataset
    2. Ask for the number of layers and number of units in them
    3. Create a matrix of random weights (`generateWeightsMatrix`)
    4. (?) Count the matrix of units, and find the value od Cost Function (`countActivations` and ´costFunction´)
    5. REPEAT ---> Reduce the Cost Function by changing the weights WHILE delta between iterations is lower than given ´convergance rate´ and the number of iterations is lower than given limit:
        - 5.1. Find a list of gradients matrix using ´buildGradient´ method
        - 5.2. Find a mean gradient matrix using ´modelLearning´ method
        - 5.3. Change the weights in order to do a gradient decsent
    6. Show the graphics of: (Train error / number of iterations)

initialization file methods:

    - generateWeightsMatrix( neuronsMap ):
        return weightsMatrix
    
    - countActivations( inputs , neuronsMap, weights):

  {'input': np.array([1, 0]), 'output': np.array([0])},
  {'input': np.array([1, 1]), 'output': np.array([0])},
  {'input': np.array([0, 1]), 'output': np.array([0])},
  {'input': np.array([1, 0]), 'output': np.array([1])},
  {'input': np.array([1, 1]), 'output': np.array([1])},
  {'input': np.array([0, 0]), 'output': np.array([0])}